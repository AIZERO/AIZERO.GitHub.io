---
layout: post
title: cgo-Go切片与C数组转换
categories: [go]
tags: 
- go
- cgo
description: cgo-Go切片与C数组转换
---

假设有一个Go [] int，并想要将它传递给C * int，你可以这样做：


```
package main

/*
#include<stdio.h>

void slice(int *a){
	for(int i=0;i<4;i++){
		printf("%d\n",a[i]);
	}
}

*/
import "C"
import (
	"fmt"
)

func main() {

	intSlice := []C.int{108880, 18, 28, 83, 488}
	fmt.Println(&intSlice[0])
	C.slice(&intSlice[0])

}

```

我们可以看到当我们把Go切片中第一个元素的地址传给C中的`slice(int *a)`函数，我们就可以打印出原来Go切片中的所有元素，因此我们可以知道其实Go切片中第一个元素也就是C中Array的第一个元素，内存没有重新分配。下面我们通过一个案例来证实一下：

```
package main

import "C"
import (
	"fmt"
	"reflect"
	"unsafe"
)

func main() {
	var c int = 1

	intSlice := []int{100, 1, 2, 3, 4}
	newSlice := intSlice[c:]

	fmt.Printf("切片的指针 %p\n", &intSlice)            //0xc000004460
	fmt.Printf("指向底层数组的第一个元素: %d\n", &intSlice[0]) //824633770800

	//重点!!!!!!!!
	fmt.Printf("指向newSlice第一个元素而不是数组: %d\n", &newSlice[0]) //824633770808
	fmt.Printf("%v \n", newSlice[0])                       //1

	ref := reflect.ValueOf(newSlice)
	t := reflect.TypeOf(newSlice)

	//基础数组的起始地址
	addr := int(ref.Pointer()) - (t.Align() * c) //824633770800

	fmt.Printf("基础数据的地址: %d\n", addr) //824633770800

	underArray := (*[5]int)(unsafe.Pointer(uintptr(addr)))
	fmt.Println(*underArray) //[100 1 2 3 4]

}

```

